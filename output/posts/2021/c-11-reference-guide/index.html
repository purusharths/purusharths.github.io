<!DOCTYPE html>
<html lang="en">


  <!-- Head -->
  <head>    <!-- Metadata, OpenGraph and Schema.org -->

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>C++ 11 Reference Guide | Purusharth Saxena</title>
    <meta name="author" content="Purusharth Saxena">
    <meta name="description" content="None">    <meta name="keywords" content="applied math, mathematical modelling">
    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">


    <!-- Styles -->
    <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🤖</text></svg>">

    <link rel="stylesheet" href="https://purusharths.github.io/theme/css/main.css?dd902126">
    <link rel="canonical" href="https://purusharths.github.io/posts/2021/c-11-reference-guide/">

    <!-- Dark Mode -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="screen" id="highlight_theme_dark">

    <script src="/theme/assets/js/dark_mode_packed.js?bb014f0d"></script>
  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>
      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <div class="desktop">
<a class="navbar-brand title font-weight-lighter" href="../../../"><span class="font-weight-bold">Purusharth&nbsp;</span>Saxena</a>

          </div>
          <div class="mobile">
          <a class="navbar-brand title font-weight-lighter" href="../../../"><span class="font-weight-bold">Purusharth&nbsp;</span>Saxena</a>

          </div>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">


              <!---->

              <!-- About -->
              <li class="nav-item ">
                <!--<a class="nav-link" href="/">about--></a>
              </li>
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/posts/">Blog<span class="sr-only">(current)</span></a>
              </li>
              <!-- Other pages -->              <li class="nav-item ">
                <a class="nav-link" href="/contact/">Contact</a>
              </li>
              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>            </ul>
          </div>
        </div>
      </nav>
      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>    </header>
    <!-- Content -->
    <div class="container mt-5">
       
<!-- _layouts/post.html -->
<div class="post">

  <header class="post-header">
    <h1 class="post-title">C++ 11 Reference Guide</h1>
    <p class="post-meta">May 11, 2021&nbsp; &middot; &nbsp;Purusharth  Saxena</p>
    <p class="post-tags">
      <a href="/blog/2021"> <i class="fas fa-calendar fa-sm"></i> 2021 </a>      &nbsp; &middot; &nbsp;
<a href="/posts/tag/c/">
          <i class="fas fa-hashtag fa-sm"></i> c++</a> &nbsp;
<a href="/posts/tag/scientific-computing/">
          <i class="fas fa-hashtag fa-sm"></i> scientific-computing</a> &nbsp;
      &nbsp; &middot; &nbsp;
      <a href="/posts/category/2021/">
        <i class="fas fa-tag fa-sm"></i> 2021</a> &nbsp;

    </p>
  </header>

  <article class="post-content">
    <div id="markdown-content">
      <p>For full lecture and scirpt visit <a href="https://conan.iwr.uni-heidelberg.de/teaching/oopfsc_ws2020/">OOPFSC</a></p>
<h1 id="c-11-a-reference-guide">C++ 11 a reference guide</h1>
<h1 id="table-of-contents">Table of Contents</h1>
<ol>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#stack-heap">Stack and Heap</a></li>
<li><a href="#references">References and Pointers</a></li>
<li><a href="#static">Static</a></li>
<li><a href="#lrref">lvalue and rvalue references</a></li>
<li><a href="#const-expr">const</a></li>
<li><a href="#auto">auto</a></li>
<li><a href="#oderprecedence">order of precedence</a></li>
<li><a href="#enum">enum</a></li>
<li><a href="#moveschem">move scemantics</a></li>
<li><a href="#operatoroverload">operator overloading</a></li>
<li><a href="#funcparam">function parameter dissection(int&amp;, const )</a></li>
<li><a href="#constexpr">constexpr</a></li>
<li><a href="#explicit">explicit</a></li>
<li><a href="#inheritance">Inheritance</a></li>
</ul>
</li>
<li><a href="#funcpointer">Function Pointers</a><ul>
<li>Function Pointers</li>
<li>Functors</li>
<li>Lambda</li>
</ul>
</li>
<li><a href="#constructors">Constructors</a><ul>
<li>Default</li>
<li>Copy Constructor and copy assignment operator</li>
<li>Move Constructor and move assignment operator</li>
<li>Delegating constructor </li>
<li>Rule of three and Five</li>
</ul>
</li>
<li><a href="#stl">Standard Template Library</a></li>
<li><a href="#containers">Containers</a><ul>
<li>Sequences<ul>
<li>array</li>
<li>std::vector</li>
<li>Other Sequences</li>
</ul>
</li>
<li>Associative Containers</li>
<li>unordered map</li>
<li>Complexity Gurantee</li>
</ul>
</li>
<li><a href="#iterators">Iterators</a><ul>
<li>range based loops</li>
</ul>
</li>
<li><a href="#algorithms">Algorithms</a><ul>
<li>transform</li>
<li>bind</li>
<li>for_each</li>
<li>count_if, copy_if, find_if, shuffle</li>
</ul>
</li>
<li><a href="#companion-classes">Companion Classes</a><ul>
<li>std::pair</li>
<li>std::tuple </li>
</ul>
</li>
<li><a href="#exception">Exception</a><ul>
<li>throwing and catching exceptions</li>
<li>static</li>
<li>static_assert</li>
</ul>
</li>
<li><a href="#raii">RAII</a></li>
<li><a href="#smart-pointers">Smart Pointers</a><ul>
<li>Unique_pointer</li>
<li>Shared_pointer</li>
<li>Weak Pointer</li>
</ul>
</li>
<li><a href="#templates">Templates</a><ul>
<li>Templates</li>
<li>Templates and classes</li>
<li>Template Template Prameters</li>
<li>Template argument deduction</li>
<li>Template Specilization (explicit, partial, implicit)</li>
<li>Template Metaprogramming</li>
<li>Overloading templates</li>
<li>SFINAE</li>
<li>variadic templates</li>
</ul>
</li>
<li><a href="#polymorphism">Polymorphism</a><ul>
<li>Static<br></li>
<li>Dynamic<br></li>
</ul>
</li>
<li><a href="#threads">Threads</a></li>
<li><a href="#misc">Misc</a><ul>
<li>Using</li>
<li>typedef</li>
<li>namespaces</li>
<li>auto, decltype, declvalue</li>
<li>trailing return type</li>
<li>different ways of initialization</li>
</ul>
</li>
</ol>
<hr>
<h2 id="introduction">Introduction <a name="introduction"></a></h2>
<ul>
<li>
<h3 id="stackheap">Stack&amp;Heap</h3>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">Entity</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="c1">// on stack</span>
<span class="n">Entity</span><span class="o">*</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Entity</span><span class="p">();</span><span class="w"> </span><span class="c1">// on heap. Heap allocation returns a memory address</span>
</code></pre></div>

<ul>
<li>
<h3 id="references">References</h3>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// reference to a pointer value!!</span>
<span class="w">    </span><span class="c1">//  so that the value is not copied into a new vairable.</span>
<span class="w">    </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="c1">// value at address of a.</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">d</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="c1">// value at address of a</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">e</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="nl">OUTPUT</span><span class="p">:</span><span class="w"> </span>
<span class="mi">5</span>
<span class="mi">5</span>
<span class="mh">0x7fffb10d4db4</span>
<span class="mi">5</span>
<span class="mi">2</span>
</code></pre></div>

<ul>
<li>
<h3 id="static">Static</h3>
</li>
<li>
<h3 id="lrref">lrref</h3>
</li>
<li>
<h3 id="const">const</h3>
</li>
<li>
<h3 id="auto">Auto</h3>
</li>
<li>
<h3 id="order-of-precedence">order of precedence</h3>
<p><code>(*foo)(20)</code>: <code>(*foo)</code>is a pointer pointing to a function with inteer args
  <code>cpp
  [] &gt; *
    *foo(20) -&gt; points to the value of foo with paramter 20
    (*foo)(20) -&gt; 
      |     |__________&gt; Give 20 as param to it
   Location of  foo -----------^</code></p>
</li>
<li>
<h3 id="enum">enum</h3>
</li>
<li>
<h3 id="move-scemantics">move scemantics</h3>
</li>
<li>
<h3 id="operator-overloading">operator overloading</h3>
</li>
<li>
<h3 id="function-parameter-dissection-int-const">function parameter dissection (int&amp;, const )</h3>
</li>
<li>
<h3 id="constexpr">constexpr</h3>
</li>
<li>
<h3 id="explicit">explicit</h3>
</li>
<li>
<h3 id="inheritance">inheritance</h3>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">prot</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Base</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">prot</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// initlize prot to default</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">prot</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Derived</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Calling Base class Constructor</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">prot</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Base</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">prot</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// initlize prot to default</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Derived</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">Base</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">prot</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Derived</span><span class="w"> </span><span class="n">d</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p><code>friend</code>: private members of a class are not accessible to outside code, unless a class is marked as friend.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Friend class</span>

<span class="k">class</span><span class="w"> </span><span class="nc">GetCustomerData</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">GetName</span><span class="p">(</span><span class="n">Customer</span><span class="w"> </span><span class="o">&amp;</span><span class="n">customer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">customer</span><span class="p">.</span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Customer</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">GetCustomerData</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Customer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Customer</span><span class="w"> </span><span class="n">tom</span><span class="p">(</span><span class="s">&quot;Tom&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">GetCustomerData</span><span class="w"> </span><span class="n">getName</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">getName</span><span class="p">.</span><span class="n">GetName</span><span class="p">(</span><span class="n">tom</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Generic type: Shape</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>

<span class="w">    </span><span class="n">Shape</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">){</span>
<span class="w">        </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="w">        </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// structs have public constructors</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">Area</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Circle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Shape</span><span class="p">{</span>
<span class="w">    </span><span class="n">Circle</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">width</span><span class="p">){</span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">Area</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mf">3.1459</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">((</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">Shape</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Square Area: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">Area</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="n">Circle</span><span class="w"> </span><span class="n">circle</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Circle Area: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">circle</span><span class="p">.</span><span class="n">Area</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="n">Shape</span><span class="w"> </span><span class="n">rectangle</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">15</span><span class="p">};</span><span class="w"> </span><span class="c1">// initilization by aggreegate</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Square Area: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rectangle</span><span class="p">.</span><span class="n">Area</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<hr>
<h2 id="function-pointers">Function Pointers <a name="funcpointer"></a></h2>
<ul>
<li>
<h3 id="function-pointers_1">Function Pointers</h3>
<p>Normal pointers but points to a function.
  ```cpp
  int func(a, b){
      return a+b;
  }</p>
<p>(*func)(1,2)
  <code>Example:</code>cpp
    double someComplexFunction(int val) { return sin(val) + tan(val); }</p>
<div class="highlight"><pre><span></span><code><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">PrintVector</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">&quot;: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="nb nb-Type">void</span><span class="w"> </span><span class="n">ForEach</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">vector</span>
<span class="o">//</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">returns</span><span class="w"> </span><span class="n">double</span>
<span class="w">             </span><span class="n">double</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mathfunc</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">val</span><span class="p">),</span><span class="w"> </span>
<span class="w">             </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">printfunc</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">val2</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printfunc</span><span class="p">(</span><span class="n">mathfunc</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">};</span>
<span class="n">ForEach</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">someComplexFunction</span><span class="p">,</span><span class="w"> </span><span class="n">PrintVector</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><code>+ ### Functors
+ Are like Function objects, works as function and are created by overloading ``operator()``.
+ Basically overload the `()` operator so that it can be called by the object as fuction.
+ Used in built-in functions, parameter bindings, and play an important role in STL.</code>cpp
double POW(double x, double y) { return pow(x, y); }</p>
<p>// pratical example
// can't use template because the value can be non-constant during compile 
// time add2 is just clunky</p>
<p>template <typename T> class AddValue {
  T val;</p>
<p>public:
  AddValue(T j) : val(j) {}
  void operator()(T i) { std::cout &lt;&lt; i + val &lt;&lt; std::endl; }
};</p>
<p>class TestFunct {
public:
  TestFunct(double x) : value(x){};
  double operator()(double val) { return value * val; }
  operator std::string() const { return "X"; }
  double get_value() const { return value; }</p>
<p>private:
  double value;
};</p>
<p>int main() {
  // -------------------------------------------------<strong> USE OF FUNCTORS </strong>/
  //   TestFunct t(2);
  //   t(5);
  //   std::cout &lt;&lt; t(5)  &lt;&lt; std::endl;
  //   std::cout &lt;&lt; (std::string)t &lt;&lt; std::endl;</p>
<p>// -----------------------------------------------** 1. Built in functions
  int a = 4, b = 5;
  if (std::less<int>()(a, b)) { // a &lt; b search for other built in funcitons
  }</p>
<p>//---------------------------------------------------- 2. Parameterized
  // Functions
  AddValue<int> adval(20);
  std::vector<int> vec = {1, 2};
  int x = 20; // will not work with templates
  std::for_each(vec.begin(), vec.end(), AddValue<int>(x));</p>
<p>//------------------------------------------------------- 3. Parameter
  // Binding
  std::set<int> myset = {2, 3, 5,
                         6}; // multiply with 10 and save the result in vec3
  std::vector<int> vec3;</p>
<p>int x3 = std::multiplies<int>()(2, 3);</p>
<p>std::transform(
      myset.begin(), myset.end(),
      std::back_inserter(vec), // save the result in vec
      std::bind(std::multiplies<int>(), std::placeholders::_1,
                10)); // bind function because transform takes only oneparam 
                    //  placeholder -&gt; first param from set and second is 10</p>
<p>// //------------------------------------------- 4. convert function to
  // functor</p>
<p>auto f = std::function<double(double, double)>(POW); // now a functor?
}
```</p>
</li>
<li>
<h3 id="lambda">Lambda</h3>
<p>Throwaway functions
    <code>[capture clause] (parameters) -&gt; return-type  { definition of method }</code> 
    eg:</p>
<p><code>cpp  
  auto func_square = [&amp;](int i) mutable  {a = 1;return i*i+a;};</code>
   When you start to write more complex lambdas you will quickly encounter cases where the return type cannot be deduced by the compiler. To resolve this you are allowed to explicitly specify a return type for a lambda function, using -&gt; T:
  <code>cpp  
    void func4(std::vector&lt;double&gt;&amp; v) {
    std::transform(v.begin(), v.end(), v.begin(),
    [](double d) -&gt; double {
        if (d &lt; 0.0001) {
            return 0;
        } else {
            return d;
        }
    });
    }</code>
  #### "Capturing" variables
  So far we've not used anything other than what was passed to the lambda within it, but we can also use other variables, within the lambda. If you want to access other variables you can use the capture clause (the [] of the expression), which has so far been unused in these examples, e.g.:
  <code>cpp
  void func5(std::vector&lt;double&gt;&amp; v, const double&amp; epsilon) {
        ...
          [epsilon](double d) -&gt; double { ... }
        ...</code>
  + Can capture both by reference and value.
    + <code>[&amp;epsilon]</code> captures by reference
    + <code>[&amp;]</code> captures all variables used in the lambda by reference
    + <code>[=]</code> captures all variables used in the lambda by value
    + <code>[&amp;, epsilon]</code> captures variables like with [&amp;], but epsilon by value
    + <code>[=, &amp;epsilon]</code> captures variables like with [=], but epsilon by reference</p>
</li>
</ul>
<hr>
<h2 id="constructors">Constructors <a name="constructor"></a></h2>
<p>From GFG:</p>
<blockquote>
<p>Let us understand the types of constructors in C++ by taking a real-world example. Suppose you went to a shop to buy a marker. When you want to buy a marker, what are the options? The first one you go to a shop and say give me a marker. So just saying give me a marker mean that you did not set which brand name and which color, you didn’t mention anything just say you want a marker. So when we said just I want a marker so whatever the frequently sold marker is there in the market or in his shop he will simply hand over that. And this is what a default constructor is! The second method you go to a shop and say I want a marker a red in color and XYZ brand. So you are mentioning this and he will give you that marker. So in this case you have given the parameters. And this is what a parameterized constructor is! Then the third one you go to a shop and say I want a marker like this(a physical marker on your hand). So the shopkeeper will see that marker. Okay, and he will give a new marker for you. So copy of that marker. And that’s what copy constructor is!
  + ### Default
  Default constructor is the constructor which doesn’t take any argument. It has no parameters. If we do not specify a constructor, C++ compiler generates a default constructor for us (expects no parameters and has an empty body).
  <code>cpp
    construct(){
        a = 10;
        b = 20;
    }</code>
Even if we do not define any constructor explicitly, the compiler will automatically provide a default constructor implicitly.</p>
</blockquote>
<ul>
<li>
<h3 id="copy-constructor-and-copy-assignment-operator">Copy Constructor and copy assignment operator</h3>
  Copy constructor is used when an object is being copied. A copy constructor performs a deep copy of all the member variables especially pointers.
  Classes have shallow copy by default.
  ```cpp
  // Copying basics
    struct Vector2 {
      float x, y;
    };<p>int main() {
  int a = 2;
  int b = a; // two seprate vars created
  b = 3; // changing the value of b dosen't effect a
  std::cout &lt;&lt; a &lt;&lt; std::endl;  // 2</p>
<p>Vector2 original = {3, 5};
  Vector2 copy = original; // two seprate vars created
  copy.x = 10; // changing the value of copy dosen't affect original
  std::cout &lt;&lt; original.x &lt;&lt; std::endl; // 3</p>
<p>Vector2 <em>heap_original = new Vector2(); 
  Vector2 </em>heap_copy = heap_original; // copying the memory address</p>
<p>// changing the value of copy DOES change the value of original
  heap_copy-&gt;x = 10;  </p>
<p>std::cout &lt;&lt; heap_original-&gt;x &lt;&lt; std::endl;  // 10
}
  ```
  This is problamatic, because if we had created a copy and the original object was deleted (calling the destructor to the original pointer), the copied object will refer to a freed up memory (segmentation fault).</p>
</li>
</ul>
<p>Copy constructor takes the const object of the same class: <code>ClassName(const ClassName &amp;old_obj)</code>.
  ```cpp 
  class String{
    private:
      char *m_buffer;
      size_t m_size;</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">String</span><span class="o">(</span><span class="kd">const</span><span class="w"> </span><span class="n">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="c1">// Paramterized constructor</span>
<span class="w">    </span><span class="n">m_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
<span class="w">    </span><span class="n">m_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">char</span><span class="o">[</span><span class="n">m_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">];</span>
<span class="w">    </span><span class="n">memcpy</span><span class="o">(</span><span class="n">m_buffer</span><span class="o">,</span><span class="w"> </span><span class="n">str</span><span class="o">,</span><span class="w"> </span><span class="n">m_size</span><span class="o">);</span>
<span class="w">  </span><span class="o">}</span>
<span class="c1">// String s2 = s1;</span>
<span class="w">  </span><span class="n">String</span><span class="o">(</span><span class="kd">const</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="o">&amp;</span><span class="n">strobj</span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="c1">// Copy constructor</span>
<span class="w">    </span><span class="n">m_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strobj</span><span class="o">.</span><span class="na">m_size</span><span class="o">;</span><span class="w"> </span><span class="c1">// copy the size of the object being passed</span>
<span class="w">    </span><span class="c1">// m_size = s1.size;</span>
<span class="w">    </span><span class="n">memcpy</span><span class="o">(</span><span class="n">m_buffer</span><span class="o">,</span><span class="w"> </span><span class="n">strobj</span><span class="o">.</span><span class="na">m_buffer</span><span class="o">,</span><span class="w"> </span><span class="n">m_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">);</span>
<span class="w">  </span><span class="o">}</span>
</code></pre></div>

<p>}
  <code>Copy assignment operator
  The assignment operator for a class is what allows you to use = to assign one instance to another. For example:</code>cpp
  MyClass c1, c2;
  c1 = c2;  // assigns c2 to c1 
  <code>If you do not declare an assignment operator, the compiler gives you one implicitly. The implicit assignment operator does member-wise assignment of each data member from the source object.</code>cpp
      Test t1, t2;
      t2 = t1;  // calls assignment operator, same as "t2.operator=(t1);"
      Test t3 = t1;  // calls copy constructor, same as "Test t3(t1);"
  ```</p>
<p>Set copy constructor to <code>delete</code> to disable copying (for instance in unique pointers). 
  <code>cpp
  String(const char* str) = delete;</code>
  + ### Move Constructor and move assignment operator
    #### lvalue and rvalue references
    + lvalue: an object that occupies some identifiable location in memory.
    + rvalue: an object that is not lvalue
        + <code>int i;</code> lvalue because <code>&amp;i</code> gives the location of i.
        + (i+2),(x+y) are rvalues, &amp;(i+2) gives an error.
    + References in general are lvalue references.
    + lvalues can be implicitly transformed into rvalues, but not the other way around.</p>
<div class="highlight"><pre><span></span><code><span class="n">Returning</span><span class="w"> </span><span class="n">lvalues</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">function</span><span class="o">:</span>
<span class="err">```</span><span class="n">cpp</span>
<span class="kr">int</span><span class="w"> </span><span class="n">global</span><span class="p">;</span>

<span class="kr">int</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">foo</span><span class="p">(){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">global</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">...</span>

<span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5000</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">global</span><span class="p">;</span><span class="w"> </span><span class="c1">// 5000</span>
<span class="err">```</span>
<span class="n">C</span><span class="o">++</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">lot</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">references</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">references</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="n">both</span><span class="w"> </span><span class="n">lvalues</span><span class="w"> </span><span class="o">and</span><span class="w"> </span><span class="n">rvalues</span><span class="p">.</span>

<span class="err">```</span><span class="n">cpp</span><span class="w"> </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="c1">// lvalue reference with const - it can accept rvalues as well</span>
<span class="kr">void</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="kr">const</span><span class="w"> </span><span class="kr">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">void</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="kr">int</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// rvalue reference</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Called with value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>
<span class="w">  </span><span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="n">function</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
<span class="err">```</span>
<span class="n">Note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">rvalue</span><span class="w"> </span><span class="n">references</span><span class="w"> </span><span class="n">don</span><span class="w"> </span><span class="o">not</span><span class="w"> </span><span class="n">necerssirely</span><span class="w"> </span><span class="n">denote</span><span class="w"> </span><span class="n">rvalue</span><span class="w"> </span><span class="n">refernce</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">templated</span><span class="w"> </span><span class="n">functions</span><span class="p">.</span><span class="w"> </span><span class="n">It</span><span class="w"> </span><span class="n">depends</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">teh</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">instantiate</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">template</span><span class="p">.</span><span class="w"> </span>
<span class="n">If</span><span class="w"> </span><span class="n">instantiated</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">lvalue</span><span class="o">/</span><span class="n">rvalue</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">collapses</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">lvalue</span><span class="o">/</span><span class="n">rvalue</span><span class="w"> </span><span class="n">respectively</span><span class="p">.</span>

<span class="n">With</span><span class="w"> </span><span class="n">rvalue</span><span class="w"> </span><span class="n">references</span><span class="p">,</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">way</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">detect</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="p">(</span><span class="n">since</span><span class="w"> </span><span class="n">rvalue</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">essence</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">temp</span><span class="p">).</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="n">way</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">arrange</span><span class="w"> </span><span class="n">something</span><span class="w"> </span><span class="n">special</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="n">values</span><span class="p">.</span>

<span class="o">**</span><span class="n">Rvalue</span><span class="w"> </span><span class="n">references</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nf">move</span><span class="w"> </span><span class="n">schemantics</span><span class="w"> </span><span class="o">and</span><span class="w"> </span><span class="n">perfect</span><span class="w"> </span><span class="n">forawrding</span><span class="o">**</span>

<span class="o">+</span><span class="w"> </span><span class="err">####</span><span class="w"> </span><span class="n">Move</span><span class="w"> </span><span class="n">Schemantics</span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">allows</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nf">move</span><span class="w"> </span><span class="n">objects</span><span class="w"> </span><span class="n">around</span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">biggest</span><span class="w"> </span><span class="n">usecase</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">rvalue</span><span class="p">.</span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">wasn</span><span class="err">&#39;</span><span class="n">t</span><span class="w"> </span><span class="n">possible</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">c</span><span class="o">++</span><span class="mi">11</span>

<span class="n">Move</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="n">moves</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">resources</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">heap</span><span class="w"> </span><span class="p">(</span><span class="n">instead</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">copying</span><span class="p">),</span><span class="w">  </span><span class="n">preventing</span><span class="w"> </span><span class="n">unnecessary</span><span class="w"> </span><span class="n">copying</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">memory</span><span class="p">.</span>

<span class="err">```</span><span class="n">cpp</span>
<span class="w">              </span><span class="c1">// rvalue reference</span>
<span class="w">    </span><span class="n">Object_name</span><span class="p">(</span><span class="n">Object_name</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">obj</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">{</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Nulling out the pointer to the temporary data</span>
<span class="w">        </span><span class="n">obj</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">```</span>

<span class="err">```</span><span class="n">cpp</span>
<span class="kr">private</span><span class="o">:</span>
<span class="w">   </span><span class="kr">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">   </span><span class="p">..</span>
<span class="kr">public</span><span class="o">:</span>
<span class="w">   </span><span class="n">Move</span><span class="p">(</span><span class="n">Move</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">{</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">source</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span><span class="w">    </span>
<span class="err">```</span>
<span class="o">+</span><span class="w"> </span><span class="err">####</span><span class="w"> </span><span class="n">Perfect</span><span class="w"> </span><span class="n">forwarding</span>
</code></pre></div>

<ul>
<li>
<h3 id="delegating-converting-constructor">Delegating / converting constructor</h3>
<ul>
<li>Allows a constructor to invoke another constructor.</li>
<li>Reduces code duplication.
<code>cpp
// default constructor delegates the assignemnt to Paramterized constructor
Entity() : Entity(0, 0) { 
 std::cout &lt;&lt; "Default Constructor " &lt;&lt; std::endl; 
}
Entity(int val1, int val2) : Entity(val1, val2, 0) {
std::cout &lt;&lt; "Double Constructor with values " &lt;&lt; val1 &lt;&lt; " " &lt;&lt; val2
          &lt;&lt; std::endl;
}
Entity(int val1, int val2, int val3) : a(val1), b(val2), c(val3) {
std::cout &lt;&lt; "Final Constructor with values " &lt;&lt; val1 &lt;&lt; " " &lt;&lt; val2 &lt;&lt; " "
          &lt;&lt; val3 &lt;&lt; std::endl;
}
~Entity() {}
};</code></li>
</ul>
</li>
<li>
<h3 id="rule-of-three-and-five">Rule of three and Five</h3>
</li>
</ul>
<h2 id="standard-template-library">Standard Template Library <a name="#stl"></a></h2>
<p>The Standard Library is a set of classes and functions that is part of the C++ language standard. It provides most of the common “tools of the trade”: data structures and associated algorithms, I/O and file access, exception handling, etc. The components are easily recognized because they are in the std namespace.</p>
<p>Most general STL parts:
+ input and output streams
+ containers (a.k.a. data structures) and iterators
+ algorithms and functors
+ companion classes (pair and tuple)
+ exceptions</p>
<h2 id="containers">Containers <a name="containers"></a></h2>
<p>Containers are Data Structures. C++ provides different types of containers. (#addflowchart)
1. <em>Sequences</em> (Elements are associated with integer index)
    * Vector, arrays, list, dequeue, forward list.
2. <em>Associative Containers</em> (Arbitary index type)
    * set, map, multi-set, multi-map.
3. <em>Unsorted associative containers</em> (based on hash tables, faster than associative containers)
4. <em>Container Adapters</em>
    * Stack (LIFO), Queue (FIFO), Priority Queue.</p>
<p>The elements of container objects all have the same type, specified as a template parameter. This restriction can be somewhat lifted through dynamic polymorphism (how?)
1. ## Sequences
  + ### array
  ```c++int stack_array[20];
    int<em> arr = new int[10]; // heap
    int</em> ptr = arr; // array var itself is a pointer</p>
<div class="highlight"><pre><span></span><code><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">changes</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">a</span>

<span class="k">for</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="err">{</span>
<span class="w">    </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]&lt;&lt;</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">endl</span><span class="p">;</span>
<span class="err">}</span>


<span class="k">OUTPUT</span>
<span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
</code></pre></div>

<p><code>+ ### std::vector
      Creation:</code>c++ 
      std::vector<typename> first = {1,2};
      std::vector<int> second (4,100); // four ints with value 100
      std::vector<int> third (second); // a copy of second
      std::vecotr<int> test;
      test.push_back(10); // add 10 to test
      test.push_back({4,5,6});
      <code>Create a 2D vector and initilize all entries to 0</code>cpp
        int main(){ 
            int m = 2, n = 5;
            vector<vector\<int>> vec(m, vector<int> (n, 0));
            return 0;
        }
      <code>Access elements with `test.get(0)` or `test[0]` (Operator [] was overloaded for easier access)
      While resizing, `std::vector` needs to copy all elements (?).
      Looping through the vector: use for-each</code>cpp
      for(int&amp; v : first){
          std::cout &lt;&lt; v &lt;&lt; std::endl;
      }
      // equivalent for loop
      for(int i = 0; i&lt; vec.size(); i++){
          std::cout &lt;&lt; v[i] &lt;&lt; std::endl;
      }
      <code>Always trasfer vectors as reference to avoid unnecessary copies. Use `const` if the vector is not expected to be modified. &lt;br&gt;
      **push_back vs emplace_back**
      STL containers now uses emplace_back which lets the container create an object rather than it being mannually created and then being copied.</code>cpp
      struct Point{ 
          int x, y;
          Point(int xp, int xy): x{xp}, y{xu} {};
      };
      int main(){
          std::vector<Point> vec;
          // push_back
          Point p1(2,2);
          vec.push_back(p1);
          // vs
          vec.emplace_back(4,4); // doesn't need a copy.
      }</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="err">```</span>
<span class="w">  </span><span class="k">With</span><span class="w"> </span><span class="n">emplace</span><span class="p">,</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">provie</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">constructor</span><span class="w"> </span><span class="n">arguments</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">container</span><span class="w"> </span><span class="n">creates</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">object</span><span class="p">.</span>

<span class="w">  </span><span class="o">**</span><span class="mi">2</span><span class="n">D</span><span class="w"> </span><span class="n">vector</span><span class="o">**</span>
<span class="w">  </span><span class="err">```</span><span class="n">cpp</span>
<span class="w">  </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">vector</span><span class="o">&lt;</span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="k">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tmp_var</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ydata</span><span class="p">.</span><span class="k">size</span><span class="p">();</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">      </span><span class="n">tmp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">xdata</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">ydata</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">));</span>
<span class="w">    </span><span class="err">}</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp_var</span><span class="p">);</span>
<span class="w">  </span><span class="err">```</span>
</code></pre></div>

<ul>
<li>
<h3 id="other-sequences">Other Sequences</h3>
<ul>
<li>array: <code>int arr[100]</code> (Stack) and <code>int* heapArray = new int[100];</code> (heap)</li>
<li>list: <code>std::list&lt;double&gt; c; // empty doubley-linked list.</code> </li>
<li>stack: <code>std::stack&lt;int, std::vector&gt; b; // Stack based on vector</code> </li>
<li>queue: <code>std::queue&lt;int, std::list&gt; d; // Queue based on list</code></li>
</ul>
</li>
<li>
<h2 id="associative-containers">Associative Containers</h2>
<ul>
<li>Set: key is unique and identical to its associated value</li>
<li>Multiset: like set, but key may appear multiple times</li>
<li>Map:  key is unique, value is pair of index and some mapped type</li>
<li>multimap:  like map, but key may appear multiple times</li>
</ul>
</li>
<li>
<h2 id="unordered-map">unordered map</h2>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map1</span><span class="p">;</span>

<span class="w">    </span><span class="n">map1</span><span class="p">[</span><span class="s">&quot;Puru&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="n">map1</span><span class="p">[</span><span class="s">&quot;C++&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// how to iterate?</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">dict</span><span class="o">::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">!=</span><span class="n">map1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="c1">// &amp; so as not to copy the values because `it` is a pointer. check test.cpp</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">first</span><span class="p">;</span><span class="c1">//it-&gt;first;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span><span class="w">        </span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="n">key</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<ol>
<li>
<h2 id="complexity-gurantee">Complexity Gurantee</h2>
<table>
<thead>
<tr>
<th></th>
<th>Access</th>
<th>Add/Del Element</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::vector</td>
<td>O(1)</td>
<td>O(1)*, O(N)</td>
</tr>
<tr>
<td>std::list</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>sorted associative containers</td>
<td>O (log N)</td>
<td>O (log N)</td>
</tr>
<tr>
<td>Unsorted associative containers</td>
<td>O(1)*,O(N)</td>
<td>O(1)*,O(N)</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>*amortized (avergaged over many calls)</p>
<p>Use vector by default. </p>
<hr>
<h2 id="iterators">Iterators <a name="iterators"></a></h2>
<p>Main way to interact with containers is via iterators. Moreover, iterators are mandatory for containers which do not have simple indexing system (contigious memory). Being generilization for pointers, iterators can be dereferenced(*) and advanced(++). For each container type there exists:</p>
<div class="highlight"><pre><span></span><code><span class="n">T</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="c1">// read/write to container</span>
<span class="n">T</span><span class="o">::</span><span class="n">const_iterator</span><span class="w"> </span><span class="c1">// read only access</span>
<span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="c1">// returns iterator pointing at the first values</span>
<span class="n">end</span><span class="p">()</span><span class="w"> </span><span class="c1">// returns iterator pointing at one pos past last element.</span>
<span class="n">cbegin</span><span class="p">()</span><span class="w"> </span><span class="c1">// read only</span>
<span class="n">cend</span><span class="p">()</span><span class="w"> </span><span class="c1">// read only</span>
<span class="n">rbegin</span><span class="o">/</span><span class="n">end</span><span class="w"> </span><span class="c1">// reverse order</span>
</code></pre></div>

<ul>
<li>
<h3 id="range-based-loops">range based loops</h3>
<p>How dows range based for loop work? Vector class provide begin and end class.</p>
<p><code>c++
for(std::vector&lt;int&gt;::iterator it = values.begin(); it != values.end(); it++){
    std::cout&lt;&lt; *it &lt;&lt;std::endl;
}</code></p>
</li>
</ul>
<blockquote>
<p>What actually is an iterator?
It's not a type or a class or an interface, infact, iterator is a concept.
It's a name for something that has the properties needed by an iterator 
1. Supporting comparision using <code>!=</code>
2. Increment using <code>++</code>
3. And dereference using <code>*</code>
Anything can be used as an iterator as long as it supports these three operations (think groups in abstract algebra).</p>
</blockquote>
<hr>
<h2 id="algorithms">Algorithms <a name="algorithms"></a></h2>
<p>Many algorithms expect some criterion, transofrm or operation which has to be supplied as a functor or lambda (eg <code>for_each</code>).</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span>
</code></pre></div>

<ul>
<li>sort: <code>std::sort(vec.begin(), vec.end());</code> // sort modifies the vector</li>
<li>reverse:     <code>std::reverse(vec.begin(), vec.end());</code></li>
<li>count the number of instances of a number: <code>std::count(vec.begin(), vec.end(), 0)</code> // count number of instances of 0</li>
<li>max: <code>int max = *std::max_element(vec.begin(), vec.end()); // max_element is an iterator</code></li>
<li>
<p>min: <code>int min = *std::min_element(vec.begin(), vec.end()); // max element is an iterator</code></p>
</li>
<li>
<h3 id="transform">transform</h3>
</li>
<li>
<h3 id="bind">bind</h3>
</li>
<li>
<h3 id="for_each">for_each</h3>
<p><code>cpp
    auto sq = [](int&amp; i) {i= i*i;}; 
    std::for_each(vec.begin(), vec.end(), sq);
    print(vec);</code></p>
</li>
<li>
<h3 id="count_if-copy_if-find_if-shuffle">count_if, copy_if, find_if, shuffle</h3>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;T &quot;</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;F &quot;</span><span class="p">;</span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">count_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">even</span><span class="p">);</span><span class="w"> </span><span class="c1">// does not modify the original vector</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>


<span class="w">    </span><span class="c1">// copy_if copy vector</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">copy_vec</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">copy_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">30</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="n">copy_vec</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// find_if </span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="w"> </span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">){</span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">);});</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;First even value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// shuffle</span>


<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">rng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span><span class="w"> </span><span class="p">{};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">shuffle</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">rng</span><span class="p">);</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
</code></pre></div>

<p>Output:</p>
<div class="highlight"><pre><span></span><code><span class="go">6 1 2 3 5 7 8 0 0 0 1 2    Original vector</span>
<span class="go">0 0 0 1 1 2 2 3 5 6 7 8    Sort (Original Vector changed)</span>
<span class="go">8 7 6 5 3 2 2 1 1 0 0 0    Reverse (Original vector changed)</span>
<span class="go">Max: 8 Min: 0</span>
<span class="go">3                          Number of occurances of 0</span>
<span class="go">--------------------</span>
<span class="go">(Reminder) Vector now: 8 7 6 5 3 2 2 1 1 0 0 0 </span>
<span class="go">--------------------</span>
<span class="go">for_each: 64 49 36 25 9 4 4 1 1 0 0 0  // i^2 (modifies original vector (!))</span>
<span class="go">count_if: T F T F F T T F F T T T  // i%2==0 (does not modify the original vector)</span>
<span class="go">copy_if:  64 49 36 -1 -1 -1 -1 -1 -1 -1 -1 -1  // copy to copy_vec if i&gt;30</span>
<span class="go">find_if   64 // first even value</span>
<span class="go">shuffle:  36 1 0 4 0 64 9 0 4 25 49 1 </span>
</code></pre></div>

<p>Recap</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="nv">each</span>:<span class="w"> </span><span class="nv">apply</span><span class="w"> </span><span class="nv">some</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">element</span><span class="w"> </span><span class="ss">(</span><span class="nv">lifting</span><span class="ss">)</span>
<span class="nv">count</span><span class="w"> </span><span class="k">if</span>:<span class="w"> </span><span class="nv">count</span><span class="w"> </span><span class="nv">elements</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">certain</span><span class="w"> </span><span class="nv">properties</span>
<span class="nv">find</span><span class="w"> </span><span class="k">if</span>:<span class="w"> </span><span class="nv">find</span><span class="w"> </span><span class="nv">first</span><span class="w"> </span><span class="nv">element</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">such</span><span class="w"> </span><span class="nv">property</span>
<span class="nv">copy</span><span class="w"> </span><span class="k">if</span>:<span class="w"> </span><span class="nv">insert</span><span class="w"> </span><span class="nv">applicable</span><span class="w"> </span><span class="nv">elements</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">other</span><span class="w"> </span><span class="nv">container</span>
<span class="nv">shuffle</span>:<span class="w"> </span><span class="nv">randomly</span><span class="w"> </span><span class="nv">re</span><span class="o">-</span><span class="nv">order</span><span class="w"> </span><span class="nv">container</span><span class="w"> </span><span class="nv">contents</span>
<span class="nv">sort</span>:<span class="w"> </span><span class="nv">sort</span><span class="w"> </span><span class="nv">container</span><span class="w"> </span><span class="nv">according</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">some</span><span class="w"> </span><span class="nv">criterion</span>
</code></pre></div>

<hr>

<h2 id="companion-classes">Companion Classes <a name="#companion-classes"></a></h2>
<ul>
<li>
<h3 id="stdpair">std::pair</h3>
<code>std::pair</code> is used to store a pair (only 2) of values of different types.
```cpp    #include <tuple>
std::pair<int, std::string> p = std::make_pair(23, "Hello");
std::cout &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; std::endl;</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="o">+</span><span class="w"> </span><span class="c1">### std::tuple</span>
<span class="err">`</span><span class="n">std</span><span class="p">::</span><span class="n">tuple</span><span class="err">`</span><span class="w"> </span><span class="n">kind</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">pair</span><span class="o">.</span><span class="w"> </span><span class="n">Instead</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">storing</span><span class="w"> </span><span class="n">just</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">tuple</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="n">arbitary</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">arbitary</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">types</span><span class="o">.</span>

<span class="err">```</span><span class="n">cpp</span>
<span class="n">std</span><span class="p">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="nb">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Test&quot;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;t&#39;</span><span class="p">);</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>get&lt;&gt;() function returns the reference to the variable stored in the tuple.</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">55</span><span class="p">;</span><span class="w"> </span><span class="c1">// changes get&lt;0&gt;(t) value to 55</span>
</code></pre></div>

<p>Different ways of creating tuple</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span><span class="w"> </span><span class="c1">// uses default constructor</span>
<span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;alpha&quot;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;d&#39;</span><span class="p">);</span>
<span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;beta&quot;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;c&#39;</span><span class="p">);</span>
</code></pre></div>

<p>Comparison</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">t2</span><span class="p">){</span><span class="w"> </span><span class="c1">// lexicographical comparision</span>
<span class="w">        </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span><span class="w"> </span><span class="c1">// assignment possible, member to member copy</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<p><code>std::tuple</code> can store references (unlike other STL containers (who always use copying or moving(?)))</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;able was i&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&gt;</span><span class="w"> </span><span class="n">t3</span><span class="p">(</span><span class="n">st</span><span class="p">);</span><span class="w"> </span><span class="c1">// single memeber tuple stores reference to the string</span>
<span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ere i saw elba&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// st  is now changed</span>
</code></pre></div>

<p>PS: to add value to referenced variable inside tuple, create reference wrapper:</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">vader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Luke, I&#39;m your...&quot;</span><span class="p">;</span>
<span class="n">t3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">vader</span><span class="p">));</span><span class="w"> </span><span class="c1">// create reference wrapper and pass it to make_tuple</span>
</code></pre></div>

<p>Unpacking tuple values
Say we want to store the value of t2 in a set of variable <code>int x; string y; char z</code>, we can do:</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span>
<span class="c1">// OR </span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span>
<span class="c1">// with std::tie, we can ignore a value if required.</span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ignore</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span>
</code></pre></div>

<p>Concatinate two tuples.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// if std::tuple&lt;int, std::string, char&gt; t2, and std::tuple&lt;std::string&gt; t3 we have</span>
<span class="k">auto</span><span class="w"> </span><span class="n">t4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple_cat</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">)</span><span class="w"> </span><span class="c1">//t4 is a tuple with &lt;int, string, char, string&gt;</span>
</code></pre></div>

<p>Tuple type traits.
This prints the tuple size of the type of t4:</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">t4</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="c1">// 4</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple_element</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">t4</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"> </span><span class="c1">// d is a string (element 1 of type of t4 is a string)</span>
</code></pre></div>

<blockquote>
<p>Note: tuple makes more sense as vector of tuples (list of tuples). </p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">tuple_vec</span><span class="p">;</span>
<span class="n">tuple_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Alpha&quot;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">));</span>
</code></pre></div>

<hr>
<h2 id="exceptions">Exceptions <a name="#exceptions"></a></h2>
<p>Error handling mechanism for situations that are not normal but may occur sporadically eg FileNotFound, MatrixIsSingular.</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(...){</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>
<h3 id="throwing-exceptions">throwing exceptions</h3>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exception&gt;</span>
<span class="p">...</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TestDest</span><span class="w"> </span><span class="nf">t1</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w"> </span><span class="c1">// object created</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">get_val</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">&quot;Received negative value&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// throwing exception</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// exception catched</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Negative value Exception&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// in pratice do something better than printing the value</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Custom exceptions</strong> may be defined by inheriting from <code>std::exception</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">StackException</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">msg</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">StackException</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">what</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">if</span><span class="w"> </span><span class="p">(...){</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">StackException</span><span class="p">(</span><span class="s">&quot;Empty Stack&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Points to consider:
+ Exceptions are for error conditions that can’t be handled locally
+ A return always returns to the immediate caller, but a throw unwinds
the call stack until a matching catch block is found
+ If none is found at all, the program is aborted (should be avoided if possible)
+ All function calls between the throw statement and the catch block are
stopped prematurely</p>
<blockquote>
<p>This means that local resources have to be handled in those intermediate functions (allocated memory, open file handles, ongoing communication) during stack unwinding. An elegant mechanism to do this automatically is → RAII.    </p>
</blockquote>
<ul>
<li>
<h3 id="assert">assert</h3>
<p>happens at run time: 
 ```cpp
 #include <cassert>
 int i = 20;
 assert(i == 9); // program will crash</p>
</li>
</ul>
<p>OUTPUT
 a.out: test.cc:6: int main(): Assertion `i==9' failed.
[1]    235265 IOT instruction (core dumped)  ./a.out
 ```</p>
<ul>
<li>
<h3 id="static_assert">static_assert</h3>
<p>Happens at compile time: </p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="c1">// value should be visible to the compiler, hence const</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;i not 9&quot;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Too large&quot;</span><span class="p">);</span>

<span class="nl">OUTPUT</span><span class="p">:</span>
<span class="n">test</span><span class="p">.</span><span class="n">cc</span><span class="o">:</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="err">‘</span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="err">’</span><span class="o">:</span>
<span class="n">test</span><span class="p">.</span><span class="n">cc</span><span class="o">:</span><span class="mi">6</span><span class="o">:</span><span class="mi">20</span><span class="o">:</span><span class="w"> </span><span class="n">error</span><span class="o">:</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">assertion</span><span class="w"> </span><span class="n">failed</span><span class="o">:</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="mi">9</span>
<span class="mi">6</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="k">static_assert</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">9</span><span class="p">);</span>
<span class="w">  </span><span class="o">|</span><span class="w">                   </span><span class="o">~^~~</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="c1">#if !defined(...) #error ... construct was used.</span>
</code></pre></div>

<h2 id="raii">RAII <a name="raii"></a></h2>
<p>Full Form: Resource Aquisition is Initilization</p>
<p>Based on the properties of constructors and destructors and their interaction with exception handling.
“Destruction is Resource Release” (DIRR) would be more appropriate, but the acronym RAII is now too well-known to change it</p>
<p>Central rules that enable RAII:
1. An object is only fully constructed when its constructor is finished.
2. A compliant constructor tries to leave the system in a state with as few
changes as possible if it can’t be completed successfully.
3. If an object consists of sub-objects, then it is constructed as far as its parts
are constructed.
4. If a scope (block, function. . . ) is left, then the destructors of all successfully
constructed objects are called.
5. An exception causes the program flow to exit all blocks between the throw
and the corresponding catch .</p>
<p>The interplay of these rules, especially the last two, automatically frees resources
before leaks can happen, even when unexpected errors occur.</p>
<p>Main idea of RAII:
* Tie resources (e.g., on the heap) to handles (on the stack)21, and let the
scoping rules handle safe acquisition and release
* Repeat this recursively for resources of resources
* Let the special rules for exceptions and destructors handle
partially-constructed objects</p>
<p><strong>Motivation:</strong>
Object created on stack are destroyed automatically but have limited size, on the other hand, objects created on heap are expected to be destroyed mannually, and failing to do so will cause memory leak. </p>
<p>Is there a way to create heap objects on Stack not have to worry about releasing their memory either manuualy or <u><em>in case of an exception</em></u> (i.e the heap objects gets destoryed as soon as it is out of scope) -&gt; This can be done by RAII</p>
<p>Example:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdexcept&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TestDest</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"> </span><span class="c1">// on heap</span>
<span class="w">  </span><span class="n">TestDest</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Created Object&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="o">~</span><span class="n">TestDest</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Deleted Array&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="c1">// new scope</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">TestDest</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span><span class="w"> </span><span class="c1">// object created</span>
<span class="w">          </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">&quot;Received negative value&quot;</span><span class="p">);</span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;EXCEPTION&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// exception occured</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="c1">// exception catched</span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Error&quot;</span><span class="n">l</span><span class="err">\</span><span class="n">n</span><span class="s">&quot;;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span><span class="c1">// object deleted. memory freed without explicitly deleting it:D</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Pratical Example: Measure time</strong></p>
<div class="highlight"><pre><span></span><code><span class="cp">#incldue &lt;iostream&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Timer</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">&gt;</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">duration</span><span class="p">;</span><span class="w">    </span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Timer</span><span class="p">(){</span>
<span class="w">        </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">Timer</span><span class="p">(){</span>
<span class="w">        </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="w">        </span><span class="n">duration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1000.0f</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ms &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Timer</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// Timer will be destroyed once out of scope and destructor will be called</span>
<span class="p">}</span>
</code></pre></div>

<hr>
<h2 id="smart-pointers">Smart Pointers <a name="smart-pointers"></a></h2>
<p>SP automates the process of calling delete by using RAII paradigm. Basically, when new is called, delete should follow "automatically" when out of scope. <u>smart pointers can be thought of as a wrapper around raw pointers.</u></p>
<p>Note: Implementation for smart pointer is is given in <code>&lt;memory&gt;</code></p>
<p>Sample Implementation:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Entity</span><span class="p">{</span>
<span class="w">     </span><span class="p">...</span><span class="w">   </span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ScopedPtr</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Entity</span><span class="o">*</span><span class="w"> </span><span class="n">m_ptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">ScopedPtr</span><span class="p">(</span><span class="n">Entity</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">m_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">){}</span>
<span class="w">    </span><span class="o">~</span><span class="n">ScopedPtr</span><span class="p">(){</span><span class="w"> </span><span class="k">delete</span><span class="w"> </span><span class="n">m_ptr</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Reminder:</span>
<span class="c1">//Entity e; // on stack</span>
<span class="c1">//Entity* e = new Entity(); // on heap. Heap allocation returns a memory address</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">ScopedPtr</span><span class="w"> </span><span class="nf">e</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Entity</span><span class="p">);</span><span class="w"> </span><span class="c1">// explicit</span>
<span class="w">    </span><span class="c1">// ScopedPtr e = new Entity; // implicit</span>
<span class="p">}</span>
</code></pre></div>

<p>Here, <code>Entity</code> gets deleted automatically once it goes out of scope, even though it was declared on heap because <b>ScopedPtr was declared on stack.</b>
+ ### Unique Pointer
    + Scoped (once it goes out of scope it will be deleted)
    + Can't copy a unique pointer
        + If a unique pointer is copied, two pointer will point at the same block of memory, and then if one pointer dies, the other (copied) pointer will still point to the block of memory (that has been freed) eventually leading to a <code>segmentation fault</code>
    + Unique Pointer's copy constructor is set to delete.
    + Unique Pointer constructor is explicit (<code>= new Entity</code> will not work)</p>
<p><strong>Syntax:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="w"> </span><span class="n">obj</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Entity</span><span class="p">);</span>
<span class="c1">// make_unique</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="k">class</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>

<p>Make unique is used for <code>UniquePtr</code> to ensure exception safety. It's safer in the sense that if constructor happens to throw an exception, we would not have a dangling pointer with no reference.</p>
<p>The unique pointers can release the ownership by using <code>.release()</code></p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Shadow&quot;</span><span class="p">);</span>
<span class="n">Animal</span><span class="o">*</span><span class="w"> </span><span class="n">dg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dog</span><span class="p">.</span><span class="n">release</span><span class="p">()</span>
</code></pre></div>

<p>Check if pointer is empty: <code>!dog // true if .release() has had been called</code> </p>
<p>Reassign to another pointer <code>dog.reset(new Animal("Smoky"));</code>. Note that <code>dog.reset() ~ dog = nullptr</code></p>
<p>Reset can destroy the object, not delete. </p>
<p>Move schemantics (<code>std::move</code>) can also be used to change the pointer. Note that if we move the pointer, the orignal pointer will be deleted. </p>
<ul>
<li>
<h3 id="shared-pointer">Shared Pointer</h3>
<ul>
<li>Can't share a <code>UniquePtr</code>, hence shared pointer.</li>
<li>Heavier than <code>UniquePtr</code></li>
<li>Uses the concept of reference counting, i.e, how many reference to pointer exists, as soon as that reference count reaches 0, the pointer is deleted.<ul>
<li>
<table>
<thead>
<tr>
<th># of Shared Ptrs</th>
<th>name</th>
<th>Reference Count</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>sp1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>sp2 (copied from sp1)</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>del sp1</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>del sp2</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>shared pointer can be compiler dependent.</li>
</ul>
</li>
</ul>
<p><strong>Syntax</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shEnt</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Entity</span><span class="p">);</span><span class="w"> </span><span class="c1">// discouraged</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sharedEntity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>

<p><code>new Entity</code> is avoided because shared pointer allocates another block of memory (<code>control block</code>) where  it stores that reference count, if <code>new Entity</code> is created and then passed to shared pointer constructor, then it's two allocation, create entity first and then the control block, it total two allocation(?). </p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Entity</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="cm">/* data */</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Entity</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Created Entity&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="o">~</span><span class="n">Entity</span><span class="p">()</span><span class="n">hn</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Destroyed Entity&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="w"> </span><span class="n">e0</span><span class="p">;</span><span class="c1">// = std::make_shared&lt;Entity&gt;();</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// std::unique_ptr&lt;Entity&gt; entity = new Entity(); will Not work since construvtor is explicit and there&#39;s no unique constructor.</span>
<span class="w">            </span><span class="c1">// std::unique_ptr&lt;Entity&gt; entity(); not preffered</span>
<span class="w">            </span><span class="c1">// USE THIS ONE: std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;(); // safer if constructo</span>
<span class="w">            </span><span class="c1">//std::unique_ptr&lt;Entity&gt; e1 = entity; // can&#39;t copy. when one dies, another dies as well.</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sharedEntity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">            </span><span class="n">e0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sharedEntity</span><span class="p">;</span>
<span class="w">            </span><span class="c1">// std::weak_ptr&lt;Entity&gt; weakEntity;</span>
<span class="w">        </span><span class="p">}</span><span class="c1">// sharedEntity dies, but e0 is still alive and holding a reference to sharedEntity</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>
<h3 id="weak-pointer">Weak Pointer</h3>
<ul>
<li>When a <code>SharedPtr</code> is assigend to a <code>WeakPtr</code> it will not incerease thre reference count.</li>
<li></li>
</ul>
</li>
</ul>
<hr>
<h2 id="templates">Templates <a name="templates"></a></h2>
<p>Writing generic code. </p>
<ul>
<li>
<h3 id="templates_1">Templates</h3>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">square</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">square</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// int version</span>
<span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">square</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">27.f</span><span class="p">)</span><span class="w"> </span><span class="c1">// float version</span>
<span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">square</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span><span class="w"> </span><span class="c1">// double version</span>
</code></pre></div>

<ul>
<li>
<h3 id="templates-and-classes">Templates and classes</h3>
Function definitions aren’t the only use case for templates, one can also automate
the generation of data types. These are known as class templates, since structs are
a special case of classes in C++</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Pair</span><span class="w"> </span><span class="p">{</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">;};</span>
<span class="n">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span><span class="w"> </span><span class="c1">// a pair of ints</span>
<span class="n">Pair</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fp</span><span class="p">;</span><span class="w"> </span><span class="c1">// a pair of floats</span>
<span class="c1">// Pair&lt;int&gt; is a data type, and can be used as such</span>
<span class="n">Pair</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ipp</span><span class="p">;</span><span class="w"> </span><span class="c1">// pair of pair of ints</span>
</code></pre></div>

<h4 id="non-type-template-parameters">Non type template parameters:</h4>
<p>There are non-type template parameters. These can also be used as compile-time constants:</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">create_array</span><span class="p">(){</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">arr</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>

<p>Non type can't be float.</p>
<h4 id="structure-of-class-templates">Structure of class templates</h4>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Measurements</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Measurements</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// :value(val) {} // default constructor</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">get_value</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">setValue</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Measurements</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Measurements</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">Measurements</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">get_value</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Measurements</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">setValue</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>

<p>Demostration of STL <code>Stack</code> container using class templates:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="k">class</span><span class="w"> </span><span class="nc">Stack</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">m_size</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">m_data</span><span class="p">;</span><span class="w"> </span><span class="c1">// = new T[m_size];</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Stack</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">m_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">m_size</span><span class="p">];</span>
<span class="w">    </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="o">~</span><span class="n">Stack</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">m_data</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">push</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">pop</span><span class="p">();</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">top</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="kt">void</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">m_data</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">  </span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="kt">void</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">current</span><span class="o">--</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="n">T</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">top</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">m_data</span><span class="p">[</span><span class="n">current</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="w">  </span><span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">  </span><span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="w">  </span><span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
<span class="w">  </span><span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>
<h3 id="template-template-prameters">Template Template Prameters</h3>
<strong>Template parameter itself is a class template</strong>
One may also use templates themselves as arguments for other templates, so-called template template parameters. These can, e.g., be used to allow choosing between different implementations:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Sequential_Container</span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">KEY</span><span class="p">,</span>
<span class="w">         </span><span class="k">typename</span><span class="w"> </span><span class="nc">VALUE</span><span class="p">,</span>
<span class="w">         </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Container_Type</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SimpleHashTable</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">KEY</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">VAL</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="n">N</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">KEY</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">Container_Type</span><span class="o">&lt;</span><span class="n">KEY</span><span class="o">&gt;</span><span class="w"> </span><span class="n">keys</span><span class="p">;</span>
<span class="w">    </span><span class="n">Container_Type</span><span class="o">&lt;</span><span class="n">VAL</span><span class="o">&gt;</span><span class="w"> </span><span class="n">values</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">SimpleHashTable</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Sequential_Container</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>

<p>here the <code>Container_Type</code> is another class which takes the template T, for instance:</p>
<p>Perhaps the best example for template template parameter is the creation of 2D vector.
<code>std::vector&lt;std::vector&lt;int&gt;&gt; vec;</code></p>
<blockquote>
<p>All three types of template parameters, i.e., types, non-type template parameters, and template template parameters, can have defaults, just like function arguments:</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">KEY</span><span class="p">,</span>
<span class="w">         </span><span class="k">typename</span><span class="w"> </span><span class="nc">VALUE</span><span class="p">,</span>
<span class="w">         </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Container_Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sequential_Container</span><span class="o">&gt;</span>
</code></pre></div>

<ul>
<li>
<h3 id="template-specilization-explicit-partial-implicit">Template Specilization (explicit, partial, implicit)</h3>
Sometimes special cases are special enough to break the rules ;)
In essence, some special cases are suposed to be treated differently.</li>
</ul>
<h4 id="full-specialization">Full Specialization:</h4>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="c1">// empty brackets</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Stack</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span>
<span class="c1">// specialization is placed after the class name in angular brackets.</span>
</code></pre></div>

<p>In this ^ example, std::string will replace any <code>type</code> parameter <code>T</code> (duh!)</p>
<p>If we're to define a function outside the class:</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">top</span><span class="p">(){</span><span class="w"> </span><span class="c1">// no template line before it</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="partial-specialization">Partial Specialization:</h4>
<p>If we have more than one type parameters, we may not choose to fix all of them, this is called Partial Specialization.</p>
<p>Sample implementation of STL Pair class with enhancments using template specializations.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"> </span>
<span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="n">U</span><span class="w"> </span><span class="n">u</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Pair</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="p">(),</span><span class="w"> </span><span class="n">u</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// construct with default values for a and b;</span>
<span class="w">  </span><span class="n">Pair</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tt</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uu</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">tt</span><span class="p">),</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">uu</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">first</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="n">U</span><span class="w"> </span><span class="n">second</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Partial Specilization with first args as string</span>
<span class="c1">// (Say storing key and value)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="w">    </span><span class="n">U</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"> </span>
<span class="k">public</span><span class="o">:</span>
<span class="w">      </span><span class="n">Pair</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">str</span><span class="p">(),</span><span class="w"> </span><span class="n">u</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">      </span><span class="n">Pair</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">U</span><span class="o">&amp;</span><span class="w"> </span><span class="n">uu</span><span class="p">)</span><span class="o">:</span><span class="n">str</span><span class="p">(</span><span class="n">str</span><span class="p">),</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">uu</span><span class="p">){}</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">first</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">str</span><span class="p">;}</span>
<span class="w">      </span><span class="n">U</span><span class="w"> </span><span class="n">second</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">u</span><span class="p">;}</span>
<span class="p">};</span>

<span class="c1">// Both template paramters to be of the same type</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="c1">// only one template param but pair is using that two times</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">tt</span><span class="p">,</span><span class="w"> </span><span class="n">uu</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Pair</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="n">tt</span><span class="p">(),</span><span class="w"> </span><span class="n">uu</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">Pair</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tt</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">uu</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">tt</span><span class="p">(</span><span class="n">tt</span><span class="p">),</span><span class="w"> </span><span class="n">uu</span><span class="p">(</span><span class="n">uu</span><span class="p">){}</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">first</span><span class="p">(){</span><span class="k">return</span><span class="w"> </span><span class="n">tt</span><span class="p">;}</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">second</span><span class="p">(){</span><span class="k">return</span><span class="w"> </span><span class="n">uu</span><span class="p">;}</span>
<span class="p">};</span>

<span class="c1">// Specialization with pointers as first type</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">U</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Pair</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(),</span><span class="w"> </span><span class="n">b</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">Pair</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">aa</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">U</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bb</span><span class="p">){}</span>

<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">first</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;};</span>
<span class="w">    </span><span class="n">U</span><span class="w"> </span><span class="nf">second</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;};</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mf">21.44</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Pair&lt;int, int&gt; pp();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">();</span>

<span class="w">    </span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dict</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">21.22</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">dictonary</span><span class="p">;</span>
<span class="w">    </span><span class="n">dictonary</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&quot;Tesla&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="template-specialization-for-functions">Template Specialization for Functions</h4>
<p>Template functions can be specalized in the same way as template classes, however, the instantiation can be complicated by overloading an argument deduction (full specialization uses same syntax as angular brackets, but in this case the compiler can use the arguments of the function to determine template parameter types).</p>
<p>Specialization in function template don't take part in overload resolution, only base templates are considered.</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="n">T</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// specialization for int</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//specialization for int pointer</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">u</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>For historical reason, function templates cant't be partially specialized but we can almost achive the same effect by overloading a template. </p>
<p>__
Indivudial member function can be specialized (if required) instead of the entire class - leaving other member functions in their generic form. <code>template&lt;&gt; int Stack&lt;int&gt;::top() { ... }</code> .</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 1. Base template: General case</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">V</span><span class="o">=</span><span class="n">U</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Pair</span><span class="p">{};</span>

<span class="c1">// 2. Partial Specialization: U=V</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">{};</span>

<span class="c1">// 3. Partial Specilization: pointers</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">V</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&lt;</span><span class="n">U</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">*&gt;</span><span class="p">{};</span>

<span class="c1">// 4. Full Specialization: int pointers</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">{};</span>

<span class="n">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">4</span>
<span class="n">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="n">via</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">2</span>
<span class="n">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">2</span>
<span class="n">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">4</span>

<span class="n">Pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">both</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="n">ambigious</span><span class="p">)</span>
</code></pre></div>

<p>Overlapping specialization are to be avoided as they cause compiler error when triggred.</p>
<h4 id="explicit-instantiation">Explicit Instantiation</h4>
<p>The way in which templates are processed means that they will be instantiated as necessary, but sometimes, we might want to forcefully instantiate a template, this is called explicit instatiation. 
This can be done for both function and class templates by using using <code>explicit instantiation directive</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// force instantiation of max template. </span>
<span class="k">template</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">max</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="c1">// it will be created even without being used anywhere.</span>

<span class="c1">// SIMILARY for class</span>
<span class="k">template</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// or instantiate just a class member function</span>
<span class="k">template</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">pop</span><span class="p">();</span>
<span class="c1">// this leaves the rest of the class as generic.</span>
</code></pre></div>

<p>Usecase: 
1. reduce compile time (Say if we know that Stack<int> will be used a lot we can instantiate in one translation unit and then refer to it with extern in others). The linker will pick it up as a normal external variable.
    ```cpp 
    #include "Stack.h"</p>
<div class="highlight"><pre><span></span><code>extern template class Stack&lt;int&gt;
void func(){
    Stack&lt;int&gt; s(10);
}
```
</code></pre></div>

<ol>
<li>Creating library using template types. The template definition that hasn't been instantiated at all will not be included in the final build. By using explicit instantiation we can make sure that they will be includede.</li>
</ol>
<p>Tl;dr -&gt; forcefully create templates.</p>
<ul>
<li>
<h3 id="templates-and-inheritance">Templates and Inheritance</h3>
Inheritance pretty much works the same way as it does with normal classes.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
<span class="p">};</span>

<span class="c1">// can inherit from the Array class</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NewArray</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w"> </span><span class="c1">// NewArray has to be declared as a template type because the </span>
<span class="w"> </span><span class="c1">// base class needs a type parameter</span>
<span class="p">};</span>


<span class="c1">// We&#39;d use it in the way we expect, providing the type in angle brackets: &lt;&gt;</span>
<span class="n">NewArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">new_a</span><span class="p">;</span>
</code></pre></div>

<p><strong>Inheriting from a specialization of base class</strong>
The base class in this example is fully specified and has a size of 10 (default argument).</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">IntArray</span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">    </span><span class="c1">// This is not a template type, </span>
<span class="w">    </span><span class="c1">// since it doesn&#39;t have to provide the template param T to base class. </span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">SIZE</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IntArrayVariableSize</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="o">&gt;</span><span class="p">{</span>

<span class="p">}</span>

<span class="c1">// can do something similar if we want have a constant type but want the type to change.</span>
</code></pre></div>

<p>Inheritance often has <em>protected members</em>. Templates can make it complicated to asscess those protected variable from derived classes. </p>
<p>If a name appears in a class but no namespace precedes it (an unqualified
name), then the compiler will look in the following order for a definition:
1. Definitions in the class
2. Definitions in independent base classes
3. Template arguments</p>
<p>Accssing <code>Base</code> classe's variable works fine as long as dervied class is also not templatised.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Works as expected since Derived accesss a specilization of Base</span>
<span class="c1">// and is itself not a template</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">prot</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Base</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">prot</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">prot</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>However, if the derived class itself is also a template, then it can't access the protected members.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// THROWS ERROR: use of undeclared variable prot</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">prot</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span>
<span class="p">};</span>
</code></pre></div>

<p>Why does it happen?
    Types of type parameter and values of non type paramteres aren't known at the time when template is defined, but what some constructs mean may depedn on those types and values. This leads to the idea of dependent and non-dependednt names. </p>
<p>When something is dependent (cannot be looked up during template definition), lookup is postponed until instantiation. This works by differnt rules, and one of these rules says that the unqualified names do not get resolved as the member of the Base class, when we're talking about the dependent types, and as a result it needs to be qualified using any of these three techniques: </p>
<div class="highlight"><pre><span></span><code><span class="n">Base</span><span class="o">::</span><span class="n">prot</span>
<span class="k">this</span><span class="o">-&gt;</span><span class="n">prot</span>
<span class="k">using</span><span class="w"> </span><span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">prot</span>
</code></pre></div>

<ul>
<li>
<h3 id="template-metaprogramming">Template Metaprogramming</h3>
</li>
</ul>
<p>Using properties of templates to manupulate/calcuate at compile time.
It was discovered during the standardization of C++ when it was found that C++ template mechanism was turing complete (template can be used to compute anything that was computable - atleast in theory). First example by Erwin Uruh (1994) who computed the prime numbers with compiler error messages. </p>
<ul>
<li>
<h5 id="caveats">Caveats:</h5>
<ul>
<li>Dosen't allow mutable state: no valruable or counted loops </li>
<li>Recursion and Recursive template generation</li>
<li>Kinda like functional programming.</li>
<li>Caculation of constant constants, generation of code fragments, creation of custom types.</li>
<li>Minimum runtime overhead, but long build times.</li>
<li>Compact and efficient code, hard to debug and understand</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Factorial</span><span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Factorial</span><span class="o">&lt;</span><span class="n">N</span><span class="mi">-1</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Same example without <code>enum</code></p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Fact</span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="o">*</span><span class="n">Fact</span><span class="o">&lt;</span><span class="n">N</span><span class="mi">-1</span><span class="o">&gt;::</span><span class="n">val</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Fact</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Fact</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;::</span><span class="n">val</span><span class="p">;</span>
</code></pre></div>

<ul>
<li>
<h3 id="overloading-templates">Overloading Templates</h3>
Just like overloading functions, but rules are slightly different. </li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstring&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Plain Template&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// what if i want to compare 3 types</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Plain Template&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tmp</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>If i want to compare pointers, the current implementation will compare addresses in pointer variable, but we want to compare values! Therefore we add:</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">tmp</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;String&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">strcmp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// this will be called with max(&quot;abcd&quot;, &quot;ab&quot;)</span>
</code></pre></div>

<p>Note: Template resolution is very particular about types. In the above example, it NEEDS a const pointer, and will not work for non-const pointer.</p>
<p>Compiler will prefer non template version if avilable rather than instatiating the template.</p>
<p>Type conversion is <strong>not</strong> used in the template paramters
+ ### type_traits
    Common problem with templates is that only certain types might be valid for the template codes that has been written (can't compare string with the code written for int/double/float etc). type_traits are a better way to check type compatibility.</p>
<p>type_traits are a way to get information about types so that we can make decisions based on type capability.</p>
<p>Eg: check if the type parameter is a char.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Simple implementation</span>
<span class="c1">// start with a struct with a single boolean value</span>
<span class="c1">// by default initialized to false.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">is_char</span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">is_char</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">is_char</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">){</span>
<span class="w">        </span><span class="c1">// char</span>
<span class="w">    </span><span class="p">}</span><span class="k">else</span><span class="p">{</span>
<span class="w">        </span><span class="c1">// not a char</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// not a char</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">);</span><span class="w"> </span><span class="c1">// char</span>
<span class="p">}</span>
</code></pre></div>

<p>C++11 has defined a number of type traits header that contains a number of useful traits that we can use to check types and capabilities.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Test</span><span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Test</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">value</span><span class="p">){</span>
<span class="w">        </span><span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span><span class="w"> </span><span class="c1">// type trait to check int</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">Test</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// no error</span>
<span class="w">    </span><span class="n">Test</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span><span class="w"> </span><span class="c1">// assertion failed</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>
<h3 id="sfinae">SFINAE</h3>
Subsitution failure is not an error.
Subsitution failure <em>generally</em> happens while choosing the template and is not an error. Failing to instantiate one of the specializations doesn’t terminate the compilation process, that happens only when <u>the pool of possible choices has been exhausted and no viable specialization was found, or several that are equally suitable</u>.</li>
</ul>
<p>How it works:
1. A traits class checks for the existance of a method.
2. <code>enable_if</code> defines a type based on the return value of the traits class.
3. Right function is then picked up by SFINAE.</p>
<p>SINAFE provides a mechanism to select b/w different template specializations at will and is achived by triggring substitution failure on purpose. This is done by using <code>enable_if</code></p>
<p>Example with <code>enable_if</code></p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// works</span>
<span class="w">    </span><span class="c1">// ERROR: error: no matching function for call to ‘function&lt;float&gt;(int, int)’</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="w">  </span><span class="c1">// doesn&#39;t work.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>It can also be displaced as a function argument (so that it also works for other types.)</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="c1">//, typename = </span>
<span class="kt">bool</span><span class="w"> </span><span class="n">Equals</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;*</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rhs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="kt">bool</span><span class="w"> </span><span class="n">Equals</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;*</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// handles imprecision</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">Equals</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Even though at the end they both end up giving us void pointers, they are not the same - the structure is diffenrent. The signature of <code>std::enable_if_t&lt;std::is_floating_point&lt;T&gt;::value&gt;* = nullptr</code> is different than <code>std::enable_if_t&lt;!std::is_floating_point&lt;T&gt;::value&gt;*</code> in the same sense as how <code>vector&lt;int&gt;</code> is different from <code>vector&lt;float&gt;</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// this function is enabled if T is floating point</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Equals</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">rhs</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rhs</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// this function is enabled if T is NOT floating point</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Equals</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">rhs</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// handles imprecision</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">Equals</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">Equals</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span><span class="w"> </span><span class="mf">2.2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Bool given as return type in <code>std::enable_if&lt;..., bool&gt;</code> because the return type of the function is not void.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="mf">1.1f</span><span class="p">,</span><span class="mf">2.2f</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Pratical Example:
For solving Linear System of equations we need to pick up a solver. Some classes have methods like <code>hasMultiplyByInverse</code> which solves the system efficiently and in specalized manner. We need to do some compile time inspection to check if this method exists.
First define a traits class:</p>
<div class="highlight"><pre><span></span><code><span class="nl">T1</span><span class="p">:</span><span class="w"> </span><span class="n">Inverse</span><span class="w"> </span><span class="n">matrix</span><span class="p">.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">hasMultiplyWithInverse</span><span class="p">{</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Helper</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="p">}</span>

<span class="w">   </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="o">&gt;</span>
<span class="w">   </span><span class="c1">// &amp;T::multiplyWithInverse: checks for the existance of </span>
<span class="w">   </span><span class="c1">// multiplyWithInverse inside T.</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Helper</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="o">::</span><span class="n">multiplyWithInverse</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">True</span><span class="w"> </span><span class="p">};</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Helper</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="n">T1</span><span class="o">::*</span><span class="p">)(</span><span class="n">T2</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">};</span>
<span class="w">    </span><span class="c1">// * is a pointer to T1 that takes T2 and returns a void(?)</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="p">...</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">M</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">V</span><span class="o">&gt;</span>
<span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">hasMultiplyWithInverse</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">solve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">M</span><span class="o">&amp;</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="c1">// implement specialized version here, can use multiplyWithInverse</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">M</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">V</span><span class="o">&gt;</span>
<span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">hasMultiplyWithInverse</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">solve</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">M</span><span class="o">&amp;</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="c1">// implement general version here, has to avoid multiplyWithInverse</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>
<h3 id="variadic-templates">Variadic Templates</h3>
Other function used with variables number of arguments: <code>printf</code>
compiler knows whwat types are being used at compile time, so we should be able to make use of that information. 
create fn with varaible args, with arg handling klogic at compile time.
Used in Tuple.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">){</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// This expands to</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T3</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="n">T3</span><span class="w"> </span><span class="n">arg3</span><span class="p">){</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>

<p>Template parameter pack: <code>typename...</code>: list of arbitary types
Function paramter pack <code>Args...</code> (arguments type matches the name of the  template parameter pack)</p>
<p>Template arguments are unpacked by recursion (not really recursion since number of arguments differ each time). </p>
<ul>
<li>Define a recursive template funciton with a special case to end recusion.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span><span class="w">  </span>
<span class="p">}</span>


<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>in <code>return val + add(args...);</code> one argument unpacks as value, and the rest are sent as parameter pack.</p>
<p><code>empalce_back</code> implementation</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Pair</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Pair</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// arbitary number of args. </span>
<span class="c1">// compiler will look for the constructor having sepecified</span>
<span class="c1">// number of args</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">empbk</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">arg</span><span class="p">...);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="w">  </span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empbk</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empbk</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// give an error, no constructor for the args</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>
<h3 id="template-argument-deduction">Template argument deduction</h3>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">function</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">){</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">function</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">// template will deduce the type by the argument as int.</span>
<span class="n">function</span><span class="p">(</span><span class="mf">5.2f</span><span class="p">)</span><span class="w"> </span><span class="c1">// template will deduce the type by the argument as float.</span>
</code></pre></div>

<hr>
<h2 id="polymorphism">Polymorphism <a name="polymorphism"></a></h2>
<p>Polymorphism: Ability of a object/fn/operator to be displayed in more than one form.</p>
<p><img alt="" src="https://i.imgur.com/NtCqyyD.jpg"></p>
<p><code>Base* obj = new Derived();</code>
When derived class object is made, Base class constructor is called first. The derived class object contains the base class obj, this allows it to call base cass function (and not the other way around).</p>
<p>Consider,</p>
<div class="highlight"><pre><span></span><code><span class="nl">Parent</span><span class="p">:</span><span class="w">  </span><span class="n">Animal</span>
<span class="nl">Derived</span><span class="p">:</span><span class="w"> </span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="n">etc</span><span class="p">.</span>

<span class="kt">void</span><span class="w"> </span><span class="n">doSomething</span><span class="p">(</span><span class="n">Animal</span><span class="o">*</span><span class="w"> </span><span class="n">animal</span><span class="p">);</span>
</code></pre></div>

<p>If it was not allowed to assign a base class object to parent reference variable, it would have been required to create seprate functions for Dog and Cat. <code>void doSomething(Dog* dg); ...</code></p>
<p><strong>With polymorphism we can use:</strong></p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">doSomething</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child1</span><span class="p">();</span>
<span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Child2</span><span class="p">();</span>

<span class="n">doSomething</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>
<span class="n">doSomething</span><span class="p">(</span><span class="n">b2</span><span class="p">);</span>
</code></pre></div>

<p>In other words, Inheritance defines an <code>IS-A</code> relationship. So we can say, derived class is a base class (or Dog is an Animal), then <em>every derived object can be treated as a Base (because it quite literally IS-A base)</em>, and hence <code>Base* b = new Derived();</code>. 
Dereferring b allows acess to the base part of Derived(?).</p>
<h4 id="more-specifically">More Specifically<a name="morespecific"></a></h4>
<p>The part that creates inheritance is <code>new Derived()</code>. LHS has nothing to do with creating instance(?) as long as <code>IS-A</code> relationship remains intact.</p>
<div class="highlight"><pre><span></span><code>Enemy og = new Ogre();
           ----------
               ^--- This part determines what can be accessed from the object.
</code></pre></div>

<p><strong>Tl;dr</strong></p>
<div class="highlight"><pre><span></span><code>Base* poly = new Derived();
</code></pre></div>

<p>poly is treated as a <code>Base</code> pointer but it is <a href="#morespecific">actually a pointer to the <code>Derived</code> (pointing to the derived)</a> [Read section: more specificly]</p>
<p>Hence we are creating a <code>Derived</code> instance and assigingn it to a <code>Base</code> type. </p>
<ul>
<li>
<h3 id="static_1">Static</h3>
<ul>
<li>If there's parameter difference, overloading will decide the function.</li>
<li></li>
</ul>
</li>
<li>
<h3 id="dynamic">Dynamic</h3>
<ul>
<li>Function Overriding (if derrived class defines same function as defined in its base class, it is known as function overriding)</li>
<li>With dynamic polymorphism, if an object of derived class calls a member function which exists in both classes (derived and base), the member function of derived class is invoked and that of base class is ignored.</li>
<li>Enables to provide specific implementation of the function which is already provided by the base class.</li>
<li>Until <code>virutal</code> functions are included there is no dynamic polymorphism.
Example:
```cpp 
class Animal {
public:
  virtual std::string sound() = 0;
};</li>
</ul>
<p>class Cat : public Animal {
public:
  std::string sound() override { return "Meow"; }
};</p>
<p>class Dog : public Animal {
public:
  std::string sound() override { return "Bark"; }
};</p>
<p>class Tiger : public Animal {
public:
  std::string sound() override { return "Roar"; }
};</p>
<p>class Pikachu : public Animal {
public:
  std::string sound() override { return "Pika"; }
};</p>
<p>int main(){
    std::vector<Animal*> creatures;</p>
<div class="highlight"><pre><span></span><code><span class="nt">creatures</span><span class="p">.</span><span class="nc">push_back</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Dog</span><span class="o">());</span>
<span class="nt">creatures</span><span class="p">.</span><span class="nc">push_back</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Tiger</span><span class="o">());</span>
<span class="nt">creatures</span><span class="p">.</span><span class="nc">push_back</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Cat</span><span class="o">());</span>
<span class="nt">creatures</span><span class="p">.</span><span class="nc">push_back</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Pikachu</span><span class="o">());</span>

<span class="nt">for</span><span class="o">(</span><span class="nt">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">creature</span><span class="o">:</span><span class="w"> </span><span class="nt">creatures</span><span class="o">)</span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">creature-</span><span class="o">&gt;</span><span class="nf">sound</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>}</p>
<p>OUTPUT:
Bark
Roar
Meow
Pika
<code>+ implementation done by vtables (using Pointer to Member ).</code>
Common Error: undefined reference to `vtable for Animal'
```
+ virtual functions -&gt; Dynamic dispatch, implemented by vtables.
+ More on vtables: 
    + Maps all virtual function to base class so that they can actually be mapped to the current overridden function at runtime.
    + This is done by including a member poitner in the actual base class that pointes to the vtables.
    + virtual is complemented by override (not required but provides improved readability and is implementation safe)
    + override will throw an error if we try to override a function which is not marked as virtual.
+ Run time costs:
    + Additional memory for vtables
    + everytime we go through the vtables, we have to determine which function to map to, which also contributes in performace overhead.
+ (?) Virtual Destructors: Can cause memory leak if the destructor in the parent class is not marked as virtual. Since we're not overwrindg the destrictor just adding it (kindof) (?). Just the  base class constructor is called and not the derived constructor as c++ doesn't know that theremight be another method.</p>
</li>
<li>
<h3 id="interface-pure-virutal-function">Interface (Pure virutal function)</h3>
<p>Define a function in the base class which does not have an implementation and eforces subclass to make the function. </p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">getName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</code></pre></div>

<p><code>getName</code> has to be implemented somewhere in order for us to have an instance of this class.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Entity</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">getname</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Entity&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Player</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Entity</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">m_name</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Player</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">getname</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">m_name</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">PrintEntity</span><span class="p">(</span><span class="n">Entity</span><span class="w"> </span><span class="o">*</span><span class="n">ent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// want c++ to know that entity passed here is a player and ask to call the</span>
<span class="w">  </span><span class="c1">// respective function</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">getname</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Start referring to player as if it&#39;s an Entity</span>
<span class="w">  </span><span class="n">Entity</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Entity</span><span class="p">();</span>
<span class="w">  </span><span class="n">PrintEntity</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="n">Player</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Player</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">PrintEntity</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">  </span><span class="n">Entity</span><span class="w"> </span><span class="o">*</span><span class="n">ent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Player</span><span class="p">(</span><span class="s">&quot;ALpha&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">PrintEntity</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>
<h3 id="abstract-base-class">Abstract Base Class</h3>
Class that only consits of Interfaces (as a template of sorts).</li>
</ul>
<hr>
<h2 id="threads">Threads <a name="thread"></a></h2>
<p>C++ had thread suppport before C++11, of course, but the availability and characteristics of these threads where dependent on the architecture and operating system, e.g., POSIX threads (pthreads) under UNIX and Linux. C++11 provides a unified interface to thread creation and management, thereby increasing interoperability and platform independence of the resulting code.</p>
<p>There are two different ways of writing such concurrent programs:
    1. low-level code based on threads, using mutexes and locks to manually manage thread interactions and data exchange
    2. higher-level code based on tasks, using futures and promises to abstract away most of the interdependencies</p>
<ul>
<li>
<h3 id="stdthread">std::thread</h3>
Syntax: <code>std::thread t1(function_value, args ...)</code> function can be <em>any</em> callable object (<code>lambda, functor, function pointer</code> etc.)
<code>t1.detach()</code> will run freely on it's own (daemon process) </li>
</ul>
<p>Once a child is detached, it'll not join back. 
Check if thread can be joined: <code>t1.joinable()</code>. The program will crash if trying to join a non-joinable thread.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>


<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello world&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// t1.join();</span>
<span class="w">    </span><span class="n">t1</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span><span class="w"> </span><span class="c1">// main thread will not wait for t1 to come</span>
<span class="w">    </span><span class="c1">// t1.join(); // error</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">joinable</span><span class="p">()){</span>
<span class="w">        </span><span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>If t1 is destroyed before the thread is joined then the program will terminate. Have to make a call weather to detach or join thread beofre it goes out of scope. Put Parent thread in RAII to make sure that the child thread joins. </p>
<p><strong>Passing by Reference &amp; Moving</strong>: 
To pass varaible by reference, use reference wrapper: <code>std::ref(var)</code>
Instead of passing by reference, try moving the value (will require function to have Rvalue reference).</p>
<p>Threads can also be moved: <code>std::thread t3 = std::move(t2);</code> (A thread cannot be copied, if ownership needs to be transferred, the only way is std::move).</p>
<p>Thread ID: <code>t1.get_id()</code>
Max Threads: <code>std::thread::hardware_concurrency()</code></p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Functor</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Funct</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">-100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;from t1: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ReferenceTest</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// std::this_thread.get_id();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; Message is: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">msg</span><span class="w">   </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This message is changed inside the fucntion&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Funct</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span>

<span class="w">  </span><span class="c1">//   std::thread t1(f1, 0);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello boy!&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// need to pass by reference</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t2</span><span class="p">(</span><span class="n">ReferenceTest</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="w"> </span><span class="c1">// change operator() to ravlaue reference and use std::move</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span>
<span class="w">  </span><span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>
<h3 id="mutex-and-lock">mutex and lock</h3>
</li>
</ul>
<h4 id="race-condition-output-of-the-program-dependeson-the-relative-execution-order-of-one-or-more-threads">Race Condition: Output of the program dependeson the relative execution order of one or more threads</h4>
<p>Mutex: mutex is a synchronization primitive - a mechanism that enforces limits on access to a resource when there are many threads of execution</p>
<p>Tl;dr: <code>Mutex is used to sync the access of common resource</code>.</p>
<p><code>mu.lock()</code> is not used because exception safety. <code>std::lock_guard</code> ensures release by RAII.
Syntax: 
<code>mu.lock(); ... mu.unlock()</code>
<code>std::lock_guard&lt;std::mutex&gt; guard(mu); // mu is mutex</code></p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mu</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">shared_print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">guard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// mu.lock();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// only one thread should print at a time.</span>
<span class="w">    </span><span class="c1">// mu.unlock();</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function1</span><span class="p">(){</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="mi">-100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
<span class="w">        </span><span class="c1">// std::cout &lt;&lt; &quot;from t1: &quot; &lt;&lt; i &lt;&lt; std::endl;</span>
<span class="w">        </span><span class="n">shared_print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;from t1: &quot;</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">     </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="n">function1</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="c1">// std::cout &lt;&lt; &quot;Main: &quot; &lt;&lt; i &lt;&lt; std::endl;</span>
<span class="w">        </span><span class="n">shared_print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;main: &quot;</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>IMPORTANT:</strong> all shared variables need to be encapsulated completely by mutex so that they are not acessible from outside the lock guard.</p>
<ol>
<li>Don't return the mutex variable</li>
<li>Dont pass f as an argument to user defined functions as theymight use f without mutex.</li>
<li>
<p>Ensure thread safetly by function design.</p>
</li>
<li>
<h3 id="stdunique_lock">std::unique_lock</h3>
<ul>
<li>Third way to lock a mutex (apart from <code>.lock()</code>, and <code>lock_guard</code>)</li>
<li>Similar to lock_guard but can be unlocked when sync part is over. </li>
<li>Useful for fine-grained locking</li>
<li><code>std::defer_lock</code> is used to create locker for the mutex and lock it later.</li>
<li>defer_lock combinded with unique_lock can unlock/lock number of times.</li>
<li>felxibility comes with a price.</li>
<li>lock_guard is faster.</li>
</ul>
</li>
<li>
<h3 id="condition-variables">Condition Variables</h3>
<ul>
<li>notifies the other waiting thread that it is done executing its own part.</li>
<li><code>std::condition_variable cond;</code> , <code>cond.notify_one()</code>, <code>cond.wait(locker)</code> (The locker is a mutex variable  - used so that thread is not sleeping with the metex lock. This will unlock it first(?)).</li>
<li>Spurious wake: thread will wake up on its own. An extra condition is given to check if the thread is expected to go back to sleep or start execution: <code>cond.wait(locker,[](){return !queue.empty()})</code>. if thread wakes up and finds out that the queue is empty, it'll go back to sleep again, otherwise it'll start executing.</li>
</ul>
</li>
<li>
<h3 id="future-and-promise">future and promise</h3>
<p><code>std::async</code>: a function that returns future. Future represents an object with which we can get something in the future.</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">// CODE too complex.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;condition_variable&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;future&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mu</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span>
<span class="w">    </span><span class="n">cond</span><span class="p">;</span><span class="w"> </span><span class="c1">// want to make sure that x = result in child thread happens first</span>
<span class="w">          </span><span class="c1">// before parent thread acts upon the variable x.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
<span class="w">  </span><span class="n">cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// std::cout &lt;&lt; &quot;Factorial: &quot; &lt;&lt; result &lt;&lt; std::endl; // RETURN the result</span>
<span class="w">  </span><span class="c1">// instead of printing.</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// since x is a shared variable between the two threads, it needs to be</span>
<span class="w">         </span><span class="c1">// proctected by some mutex</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="w">  </span><span class="n">cond</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>

<span class="w">  </span><span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Standard library provides an easier way to do this job, std::async. std::async is a function that returns future. </p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
</code></pre></div>

<p>Future is the channel from which we can get result from the child thread later on. <code>fu.get()</code> will wait until the child  finishes. can be called only once.
<code>x = fu.get();</code></p>
<p>Async may or may not create another thread. and that can be controlled by
another parameter </p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span><span class="w"> </span><span class="n">factorial</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
</code></pre></div>

<p><code>async</code> will not create the thread and will defer the execution of the function until it comes across <code>fu.get()</code>. IN THE SAME THREAD(?).</p>
<p><code>std::async(std::launch::async, factorial, 5)</code> creates another thread.</p>
<p>Default: <code>std::async(std::launch::async | std::launch::deferred)</code> creation of thread depends on implemetation.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// function doesn&#39;t need a second parameter but returns a vlaue.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Standard library provides an easier way to do this job, std::async.</span>
<span class="w">  </span><span class="c1">// std::async is a function that returns future</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>

<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fu</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"> </span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>Promise:
Promise to send the value in future. </p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">factorial</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// takes future</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"> </span><span class="c1">// Once value is recieved, it&#39;ll start the execution</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span><span class="w"> </span><span class="n">factorial</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1200</span><span class="p">));</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Setting Value to 5...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Sleeping...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1020</span><span class="p">));</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Executing seprate thread&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fu</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>
<h3 id="packaged-tasks">Packaged Tasks (?)</h3>
Package task and can be passed around to different function/obj/threads.
<code>std::package_task &lt;int&lt;int&gt;&gt; t(func)</code> </li>
</ul>
<p><code>t(6)</code> can be executed in a different context other than the palce where it is created.</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">factorial</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// t(5); // can be used in a different context.</span>
<span class="w">    </span><span class="c1">// To get return value, convert to future.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>3 ways to get future</strong>
1. async returns a future.
2. promise::get_future();
3. package_task::get_future();</p>
<ul>
<li>
<h3 id="deadlock">deadlock</h3>
</li>
<li>
<h3 id="atomic">atomic</h3>
<p>An alternative to mutexes and locks is the use of atomics. Data types can be made atomic by wrapping them in a std::atomic<T> , which provides special uninterruptible methods for the usual operations. This solves the lost update problem, because read—modify—write cycles are carried out as single operations </p>
</li>
</ul>
<p>Atomic value allows to perform an operation on one particular thread ensureing thread safety(?). Doesn't require any thread to be blocked(?). No deadlocks(?)</p>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">varname</span><span class="p">(...)</span>
<span class="n">varname</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</code></pre></div>

<hr>
<h2 id="misc">Misc <a name="misc"></a></h2>
<ul>
<li>
<h3 id="a-using">a. Using</h3>
<p>using provides an alternative to typedefs, which is more general and can also be used to give names to partial template specializations / instantiations.
 <code>`cpp
 using Number = int; // replaces</code>typedef int Number''</p>
<p>// partial specialization or instantiation
 template<typename T>
 using Vector3D = Vector<T,3>; // defines ``Vector3D<T>'</p>
<p>// alias template
 template<typename U, typename V>
 using Matrix = Long::Namespace::SpecialMatrix<U,V>;</p>
<p>// variadic alias template
 // (can also be used to just omit the arguments!)
 template<typename... T>
 using Foo = Bar<T...>; // Foo is alias of Bar     </p>
<p>```</p>
</li>
<li>
<h3 id="typedef">typedef</h3>
<p>Make alias <code>typedef int Number</code> then, <code>Number a = 5</code></p>
</li>
<li>
<h3 id="exception-free-function">exception free function</h3>
<ul>
<li>C++11 switched to specifying that a function will never throw exceptions, used for optimization purposes. There are two versions:<ul>
<li>A simple noexcept qualifier, stating that exceptions are never thrown</li>
<li>A noexcept qualifier with Boolean argument, typically using an operator
<code>cpp
// never throws an exception
int five() noexcept {return 5;}</code></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="random">random</h3>
<ul>
<li>PRNGs:
      • The Mersenne Twister (Matsumoto and Nishimura)
      • “Minimal standard” linear congrual engine (Park et al.)
      • RANLUX generator (Luscher and James)  etc</li>
<li>The generation of random numbers is divided into three distinct steps:<ul>
<li>Seeding the aforementioned engines, using true random numbers (entropy) or simply system time if the latter is sufficient</li>
<li>Generation of uniformly distributed pseudo-random integers using the engines</li>
<li>Transformation of these values into discrete or continuous target distributions</li>
</ul>
</li>
</ul>
<p><code>cpp
    std::random_device rd; // entropy source
    std::mt19937 gen{rd()}; // seed Mersenne Twister
    std::normal_distribution&lt;&gt; dist{}; // standard normal dist
    std::vector&lt;double&gt; vals(1000);
    for (auto&amp; e : vals)
    e = dist(gen); // draw value using generator</code>
with the same name</p>
<h3 id="c-namespaces">c. namespaces</h3>
<h3 id="d-trailing-return-type">d. trailing return type</h3>
<h3 id="e-different-ways-of-initialization-in-c">e. different ways of initialization in C++</h3>
<h3 id="singleton-pattern">singleton pattern</h3>
<h3 id="fold-expression">fold expression</h3>
<h3 id="one-definition-rule">one definition rule</h3>
</li>
<li>
<h3 id="extern">extern</h3>
<p>```cpp</p>
<h1 id="ifndef-header_h">ifndef HEADER_H</h1>
<h1 id="define-header_h">define HEADER_H</h1>
<p>// any source file that includes this will be able to use "global_x"
extern int global_x;
  <code>+ ### default and delete, explicit
  + #### default
    + Explicitly defaulted function declaration is a new form of function declaration that is introduced into the C++11 standard which allows you to append the ‘=default;’ specifier to the end of a function declaration to declare that function as an explicitly defaulted function. This makes the compiler generate the default implementations for explicitly defaulted functions, which are more efficient than manually programmed function implementations.
    + For example, whenever we declare a parameterized constructor, the compiler won’t create a default constructor. In such a case, we can use the default specifier in order to create a default one.</code>cpp
        class A {
        public:</p>
<div class="highlight"><pre><span></span><code><span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">parameterized</span><span class="w"> </span><span class="n">constructor</span>
<span class="w">        </span><span class="n">A</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">  </span><span class="p">{</span>
<span class="w">            </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">&quot;This is a parameterized constructor&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">Using</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">specifier</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">instruct</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">compiler</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">create</span>
<span class="w">         </span><span class="n">the</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">implementation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">constructor</span><span class="o">.</span>
<span class="w">        </span><span class="n">A</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="err">```</span>
</code></pre></div>

<ul>
<li>
<h4 id="delete">delete</h4>
<ul>
<li>To disable the usage of a member function. This is done by appending the =delete; specifier to the end of that function declaration.</li>
<li>Any member function whose usage has been disabled by using the <code>=delete</code> specifier is known as an expicitly deleted function.</li>
<li>Disabling undesirable argument conversion
  Delete can be used on any function.
  <code>cpp
  setVal(int a){
      val = a;
  }
  setVal(float) = delete; // will not compile if float.</code></li>
</ul>
</li>
<li>
<h4 id="explicit_1">explicit</h4>
<p>Suppose, you have a class <code>String</code>:
<code>cpp
class String {
public:
    String(int n); // allocate n bytes to the String object
    String(const char *p); // initializes object with char *p
};</code>
Now, if you try: <code>String mystring = 'x';</code></p>
<p>The character <code>'x'</code> will be implicitly converted to <code>int</code> and then the <code>String(int)</code> constructor will be called. But, this is not what the user might have intended. So, to prevent such conditions, we shall define the constructor as <code>explicit</code>:</p>
<p><code>cpp 
class String {
public:
    explicit String (int n); //allocate n bytes
    String(const char *p); // initialize sobject with string p
};</code>
  + ### Range based loop over intilizer lists.
      <code>cpp
    int main(){
for (const auto&amp; i : {1,2,3,4,5,6}){
    std::cout &lt;&lt; i &lt;&lt; ", ";
}
    }</code></p>
</li>
</ul>
</li>
</ul>
    </div>
  </article>
</div>


    </div>

    <!-- Footer -->
<div class="desktop">
    <footer class="fixed-bottom">
      <div class="container mt-0">
                &copy; Copyright 2025 Purusharth  Saxena. &nbsp;Last updated: May 21, 2025.
      </div>
    </footer></div>

<div class="mobile">
    <footer class="sticky-bottom mt-5">
      <div class="container mt-0">
                &copy; Copyright 2025 Purusharth  Saxena. &nbsp;Last updated: May 21, 2025.
      </div>
    </footer>
</div>
    <!-- JavaScripts -->
<!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script><!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script><!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/theme/assets/js/masonry.js" ></script>  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/theme/assets/js/zoom.js"></script>
  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="../../../theme/assets/js/no_defer_min.js?9e722202"></script>
  <script defer src="../../../theme/assets/js/common_min.js?d4f27d0b"></script>
  <script defer src="../../../theme/assets/js/copy_code_min.js?473a20b6"></script>
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>  <script async src="https://badge.dimensions.ai/badge.js"></script><!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
<!-- Scrolling Progress Bar -->
<script>
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>
  </body>
</html>